"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _events = _interopRequireDefault(require("events"));

var _parameters = _interopRequireDefault(require("@ircam/parameters"));

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _SharedStatePrivate = _interopRequireDefault(require("./SharedStatePrivate.js"));

var _SharedStateManagerClient = _interopRequireDefault(require("./SharedStateManagerClient.js"));

var _sharedStateUtils = require("./shared-state-utils.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const generateStateId = (0, _sharedStateUtils.idGenerator)();
const generateRemoteId = (0, _sharedStateUtils.idGenerator)();
/**
 * Component dedicated at managing distributed states among the application.
 * The `SharedStateManagerServer` extends the `SharedStateManagerClient` with
 * additionnal functionnalities to register schemas and handle clients.
 *
 * An instance of `SharedStateManagerClient` is automatically created by the
 * `soundworks.Server` (cf. {@link server.Server#stateManager}).
 *
 * Tutorial: [https://collective-soundworks.github.io/tutorials/state-manager.html](https://collective-soundworks.github.io/tutorials/state-manager.html)
 *
 * @memberof server
 * @extends client.SharedStateManagerClient
 *
 * @see {@link client.SharedStateManagerClient}
 * @see {@link server.SharedState}
 * @see {@link server.Server#stateManager}
 */

class SharedStateManagerServer extends _SharedStateManagerClient.default {
  constructor() {
    // acts as a client of itself locally
    const localClientId = -1;
    const localTransport = new _events.default();
    super(localClientId, localTransport);
    this._clientByNodeId = new Map();
    this._serverStatesById = new Map();
    this._schemas = new Map();
    this._observers = new Set();
    this.addClient(localClientId, localTransport);
  }
  /**
   * Add a client. This is automatically handle by `soundworks` when a client
   * connects.
   *
   * @param {Number} nodeId - Id of the client node, as given in
   *  {@link client.SharedStateManagerClient}
   * @param {Object} transport - Tranpsort mecanism to communicate with the
   *  client. Should implement a basic EventEmitter API.
   *
   * @private
   */


  addClient(nodeId, transport) {
    const client = {
      id: nodeId,
      transport
    };

    this._clientByNodeId.set(nodeId, client); // ---------------------------------------------
    // CREATE
    // ---------------------------------------------


    client.transport.addListener(_sharedStateUtils.CREATE_REQUEST, (reqId, schemaName, requireSchema, initValues = {}) => {
      if (this._schemas.has(schemaName)) {
        try {
          const schema = this._schemas.get(schemaName);

          const stateId = generateStateId.next().value;
          const remoteId = generateRemoteId.next().value; // id, schemaName, schema, manager, initValues = {}

          const state = new _SharedStatePrivate.default(stateId, schemaName, schema, this, initValues);

          state._attachClient(remoteId, client, true); // attach client to the state


          this._serverStatesById.set(stateId, state);

          const currentValues = state._parameters.getValues();

          const sendedSchema = requireSchema ? schema : null;
          client.transport.emit(_sharedStateUtils.CREATE_RESPONSE, reqId, stateId, remoteId, schemaName, sendedSchema, currentValues);

          this._observers.forEach(observer => {
            observer.transport.emit(_sharedStateUtils.OBSERVE_NOTIFICATION, [schemaName, stateId, nodeId]);
          });
        } catch (err) {
          client.transport.emit(_sharedStateUtils.CREATE_ERROR, reqId, err.message);
          console.error(err.message);
        }
      } else {
        const msg = `Cannot create state "${schemaName}", schema does not exists`;
        console.error(msg);
        client.transport.emit(_sharedStateUtils.CREATE_ERROR, reqId, msg);
      }
    }); // ---------------------------------------------
    // ATTACH (when creator, is attached by default)
    // ---------------------------------------------

    client.transport.addListener(_sharedStateUtils.ATTACH_REQUEST, (reqId, schemaName, stateId = null, requireSchema = true) => {
      if (this._schemas.has(schemaName)) {
        let state = null;

        if (stateId !== null && this._serverStatesById.has(stateId)) {
          state = this._serverStatesById.get(stateId);
        } else if (stateId === null) {
          // if no `stateId` given, we try to find the first state with the given
          // `schemaName` in the list, this allow a client to attach to a global
          // state created by the server (or some persistant client) without
          // having to know the `stateId` (e.g. some global state...)
          for (let existingState of this._serverStatesById.values()) {
            if (existingState.schemaName === schemaName) {
              state = existingState;
              break;
            }
          }
        }

        if (state !== null) {
          // @note - we use a unique remote id to allow a client to attach
          // several times to the same state.
          const remoteId = generateRemoteId.next().value;

          const schema = this._schemas.get(schemaName);

          const currentValues = state._parameters.getValues();

          state._attachClient(remoteId, client, false); // send schema for client-side instanciation


          const sendedSchema = requireSchema ? schema : null;
          client.transport.emit(_sharedStateUtils.ATTACH_RESPONSE, reqId, state.id, remoteId, schemaName, sendedSchema, currentValues);
        } else {
          const msg = `Cannot attach, no existing state for schema "${schemaName}" with stateId: "${stateId}"`;
          client.transport.emit(_sharedStateUtils.ATTACH_ERROR, reqId, msg);
          console.error(msg);
        }
      } else {
        const msg = `Cannot attach, schema "${schemaName}" does not exists`;
        client.transport.emit(_sharedStateUtils.ATTACH_ERROR, reqId, msg);
        console.error(msg);
      }
    }); // ---------------------------------------------
    // OBSERVE PEERS (be notified when a state is created, lazy)
    // ---------------------------------------------

    client.transport.addListener(_sharedStateUtils.OBSERVE_REQUEST, reqId => {
      const statesInfos = [];

      this._serverStatesById.forEach(state => {
        const {
          schemaName,
          id,
          _creatorId
        } = state;
        statesInfos.push([schemaName, id, _creatorId]);
      });

      client.transport.emit(_sharedStateUtils.OBSERVE_RESPONSE, reqId, ...statesInfos);

      this._observers.add(client);
    });
  }
  /**
   * Remove a client. This is automatically handle by `soundworks` when a client
   * connects.
   *
   * @param {Number} nodeId - Id of the client node, as given in
   *  {@link client.SharedStateManagerClient}
   *
   * @private
   */


  removeClient(nodeId) {
    for (let [id, state] of this._serverStatesById.entries()) {
      let deleteState = false; // define if the client is the creator of the state, in which case
      // everybody must delete it

      for (let [remoteId, attachedClient] of state._attachedClients.entries()) {
        if (nodeId === attachedClient.id && remoteId === state._creatorRemoteId) {
          deleteState = true;
        }
      }

      for (let [remoteId, attachedClient] of state._attachedClients.entries()) {
        if (nodeId === attachedClient.id) {
          state._detachClient(remoteId, attachedClient);
        }

        if (deleteState) {
          if (remoteId !== state._creatorRemoteId) {
            // send notification to other attached nodes
            attachedClient.transport.emit(`${_sharedStateUtils.DELETE_NOTIFICATION}-${state.id}-${remoteId}`);
          }

          this._serverStatesById.delete(state.id);
        }
      }
    } // if is an observer, delete it


    const client = this._clientByNodeId.get(nodeId);

    this._observers.delete(client);

    this._clientByNodeId.delete(nodeId);
  }
  /**
   * Register a schema. The schema definition follows the convention described
   * here [https://github.com/ircam-jstools/parameters#booleandefinition--object](https://github.com/ircam-jstools/parameters#booleandefinition--object) (@todo - document somewhere else).
   *
   * @param {String} schemaName - Name of the schema.
   * @param {Object} schema - Description of the state data structure.
   */


  registerSchema(schemaName, schema) {
    if (this._schemas.has(schemaName)) {
      throw new Error(`schema "${schemaName}" already registered`);
    } // throw is schema is invalid


    try {
      (0, _parameters.default)(schema, {});
    } catch (err) {
      throw new Error(`Invalid schema "${schemaName}": ${err.message}`);
    }

    this._schemas.set(schemaName, (0, _lodash.default)(schema));
  }
  /**
   * Delete a schema and all associated states.
   * When a schema is deleted, all attached clients are detached
   * and the `onDetach` and `onDelete` callbacks are called.
   *
   * @param {String} schemaName - Name of the schema.
   */


  deleteSchema(schemaName) {
    for (let [id, state] of this._serverStatesById.entries()) {
      if (state.schemaName === schemaName) {
        for (let [remoteId, attached] of state._attachedClients.entries()) {
          state._detachClient(remoteId, attached);

          attached.transport.emit(`${_sharedStateUtils.DELETE_NOTIFICATION}-${state.id}-${remoteId}`);
        }

        this._serverStatesById.delete(this.id);
      }
    }

    this._schemas.delete(schemaName);
  }

}

var _default = SharedStateManagerServer;
exports.default = _default;