"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _parameters = _interopRequireDefault(require("@ircam/parameters"));

var _lodash = _interopRequireDefault(require("lodash.clonedeep"));

var _sharedStateUtils = require("./shared-state-utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * The "real" state, this instance is kept private by the SharedStateServerManager.
 * It cannot be accessed without a SharedState proxy
 * @private
 */
class SharedStatePrivate {
  constructor(id, schemaName, schema, manager, initValues = {}) {
    this.id = id;
    this.schemaName = schemaName;
    this._schema = (0, _lodash.default)(schema);
    this._manager = manager;
    this._parameters = (0, _parameters.default)(schema, initValues);
    this._attachedClients = new Map(); // other peers interested in watching / controlling the state

    this._creatorRemoteId = null;
    this._creatorId = null;
  }

  _attachClient(remoteId, client, isCreator = false) {
    this._attachedClients.set(remoteId, client);

    if (isCreator) {
      this._creatorRemoteId = remoteId;
      this._creatorId = client.id;
    } // attach client listeners


    client.transport.addListener(`${_sharedStateUtils.UPDATE_REQUEST}-${this.id}-${remoteId}`, (reqId, updates) => {
      const updated = {};
      let dirty = false;

      for (let name in updates) {
        const currentValue = this._parameters.get(name); // get new value this way to store events return values


        const newValue = this._parameters.set(name, updates[name]); // we check the `schema[name].type === 'any'`, to always consider
        // objects as dirty, because if the state is attached locally, we
        // compare the Object instances instead of their values.
        // @todo - this should be made more robust but how?


        if (newValue !== currentValue || this._schema[name].type === 'any') {
          updated[name] = newValue;
          dirty = true;
        }
      }

      if (dirty) {
        // send response to requester
        // client.transport.emit(`${UPDATE_RESPONSE}-${this.id}-${remoteId}`, reqId, updated);
        // @note: we propagate server-side last, because as the server transport
        // is synchronous it can break ordering if a subscription function makes
        // itself an update in reaction to an update, therefore network messages
        // order would be broken,
        for (let [peerRemoteId, peer] of this._attachedClients.entries()) {
          // propagate notification to all other attached clients except server
          if (remoteId !== peerRemoteId && peer.id !== -1) {
            peer.transport.emit(`${_sharedStateUtils.UPDATE_NOTIFICATION}-${this.id}-${peerRemoteId}`, updated);
          }
        } // handle case where:
        // client state (client.id: 2) sends a request
        // server attached state (client.id: -1) spot a problem and overrides the value
        // we want the remote client (id: 2) to receive in the right order:
        // * 1. the value it requested,
        // * 2. the value overriden by attached state -1


        if (client.id !== -1) {
          client.transport.emit(`${_sharedStateUtils.UPDATE_RESPONSE}-${this.id}-${remoteId}`, reqId, updated);
        }

        for (let [peerRemoteId, peer] of this._attachedClients.entries()) {
          // propagate notification to server
          if (remoteId !== peerRemoteId && peer.id === -1) {
            peer.transport.emit(`${_sharedStateUtils.UPDATE_NOTIFICATION}-${this.id}-${peerRemoteId}`, updated);
          }
        }

        if (client.id === -1) {
          client.transport.emit(`${_sharedStateUtils.UPDATE_RESPONSE}-${this.id}-${remoteId}`, reqId, updated);
        }
      } else {
        // propagate back to the requester that the update has been aborted
        // ignore all other attached clients.
        client.transport.emit(`${_sharedStateUtils.UPDATE_ABORT}-${this.id}-${remoteId}`, reqId, updates);
      }
    });

    if (isCreator) {
      // delete only if creator
      client.transport.addListener(`${_sharedStateUtils.DELETE_REQUEST}-${this.id}-${remoteId}`, reqId => {
        this._manager._serverStatesById.delete(this.id); // --------------------------------------------------------------------
        // WARNING - MAKE SURE WE DON'T HAVE PROBLEM W/ THAT
        // --------------------------------------------------------------------
        // @todo - propagate server-side last, because if a subscription function sends a
        // message to a client, network messages order are kept coherent
        // this._subscriptions.forEach(func => func(updated));


        for (let [remoteId, attached] of this._attachedClients.entries()) {
          this._detachClient(remoteId, attached);

          if (remoteId === this._creatorRemoteId) {
            attached.transport.emit(`${_sharedStateUtils.DELETE_RESPONSE}-${this.id}-${remoteId}`, reqId);
          } else {
            attached.transport.emit(`${_sharedStateUtils.DELETE_NOTIFICATION}-${this.id}-${remoteId}`);
          }
        }
      });
    } else {
      // detach only if not creator
      client.transport.addListener(`${_sharedStateUtils.DETACH_REQUEST}-${this.id}-${remoteId}`, reqId => {
        this._detachClient(remoteId, client);

        client.transport.emit(`${_sharedStateUtils.DETACH_RESPONSE}-${this.id}-${remoteId}`, reqId);
      });
    }
  }

  _detachClient(remoteId, client) {
    this._attachedClients.delete(remoteId); // delete listeners


    client.transport.removeAllListeners(`${_sharedStateUtils.UPDATE_REQUEST}-${this.id}-${remoteId}`);
    client.transport.removeAllListeners(`${_sharedStateUtils.DELETE_REQUEST}-${this.id}-${remoteId}`);
    client.transport.removeAllListeners(`${_sharedStateUtils.DETACH_REQUEST}-${this.id}-${remoteId}`);
  }

}

var _default = SharedStatePrivate;
exports.default = _default;