'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _paramTemplates = require('./paramTemplates');

var _paramTemplates2 = _interopRequireDefault(_paramTemplates);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Generic class for typed parameters.
 *
 * @param {String} name - Name of the parameter.
 * @param {Array} definitionTemplate - List of mandatory keys in the param
 *  definition.
 * @param {Function} typeCheckFunction - Function to be used in order to check
 *  the value against the param definition.
 * @param {Object} definition - Definition of the parameter.
 * @param {Mixed} value - Value of the parameter.
 * @private
 */
var Param = function () {
  function Param(name, definitionTemplate, typeCheckFunction, definition, value) {
    _classCallCheck(this, Param);

    definitionTemplate.forEach(function (key) {
      if (definition.hasOwnProperty(key) === false) throw new Error('Invalid definition for param "' + name + '", ' + key + ' is not defined');
    });

    this.name = name;
    this.type = definition.type;
    this.definition = definition;

    if (this.definition.nullable === true && value === null) {
      this.value = null;
    } else {
      this.value = typeCheckFunction(value, definition, name);
    }

    this._typeCheckFunction = typeCheckFunction;
  }

  /**
   * Returns the current value.
   * @return {Mixed}
   */


  _createClass(Param, [{
    key: 'getValue',
    value: function getValue() {
      return this.value;
    }

    /**
     * Update the current value.
     * @param {Mixed} value - New value of the parameter.
     * @return {Boolean} - `true` if the param has been updated, false otherwise
     *  (e.g. if the parameter already had this value).
     */

  }, {
    key: 'setValue',
    value: function setValue(value) {
      if (this.definition.constant === true) {
        throw new Error('Invalid assignement to constant param "' + this.name + '"');
      }

      if (!(this.definition.nullable === true && value === null)) {
        value = this._typeCheckFunction(value, this.definition, this.name);
      }

      if (this.value !== value) {
        this.value = value;
        return true;
      }

      return false;
    }
  }]);

  return Param;
}();

/**
 * Bag of parameters. Main interface of the library
 */


var ParameterBag = function () {
  function ParameterBag(params, definitions) {
    _classCallCheck(this, ParameterBag);

    /**
     * List of parameters.
     *
     * @type {Object<String, Param>}
     * @name _params
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._params = params;

    /**
     * List of definitions with init values.
     *
     * @type {Object<String, paramDefinition>}
     * @name _definitions
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._definitions = definitions;

    /**
     * List of global listeners.
     *
     * @type {Set}
     * @name _globalListeners
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._globalListeners = new Set();

    /**
     * List of params listeners.
     *
     * @type {Object<String, Set>}
     * @name _paramsListeners
     * @memberof ParameterBag
     * @instance
     * @private
     */
    this._paramsListeners = {};

    // initialize empty Set for each param
    for (var name in params) {
      this._paramsListeners[name] = new Set();
    }
  }

  /**
   * Return the given definitions along with the initialization values.
   *
   * @return {Object}
   */


  _createClass(ParameterBag, [{
    key: 'getDefinitions',
    value: function getDefinitions() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (name !== null) {
        return this._definitions[name];
      } else {
        return this._definitions;
      }
    }

    /**
     * Return values of all parameters as a flat object.
     *
     * @return {Object}
     */

  }, {
    key: 'getValues',
    value: function getValues() {
      var values = {};

      for (var name in this._params) {
        values[name] = this._params[name].value;
      }

      return values;
    }

    /**
     * Return the value of the given parameter.
     *
     * @param {String} name - Name of the parameter.
     * @return {Mixed} - Value of the parameter.
     */

  }, {
    key: 'get',
    value: function get(name) {
      if (!this._params[name]) throw new Error('Cannot read property value of undefined parameter "' + name + '"');

      return this._params[name].value;
    }

    /**
     * Set the value of a parameter. If the value of the parameter is updated
     * (aka if previous value is different from new value) all registered
     * callbacks are registered.
     *
     * @param {String} name - Name of the parameter.
     * @param {Mixed} value - Value of the parameter.
     * @param {Boolean} [forcePropagation=false] - if true, propagate value even
     *    if the value has not changed.
     * @return {Mixed} - New value of the parameter.
     */

  }, {
    key: 'set',
    value: function set(name, value) {
      var forcePropagation = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      var param = this._params[name];
      var updated = param.setValue(value);
      value = param.getValue();

      if (param.definition.event === true) {
        param.setValue(null);
      }

      if (updated || forcePropagation) {
        var metas = param.definition.metas;
        // trigger global listeners
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._globalListeners[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var listener = _step.value;

            listener(name, value, metas);
          }

          // trigger param listeners
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._paramsListeners[name][Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var _listener = _step2.value;

            _listener(value, metas);
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }

      return value;
    }

    /**
     * Define if the `name` parameter exists or not.
     *
     * @param {String} name - Name of the parameter.
     * @return {Boolean}
     */

  }, {
    key: 'has',
    value: function has(name) {
      return this._params[name] ? true : false;
    }

    /**
     * Reset a parameter to its init value. Reset all parameters if no argument.
     *
     * @param {String} [name=null] - Name of the parameter to reset.
     */

  }, {
    key: 'reset',
    value: function reset() {
      var _this = this;

      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (name !== null) this.set(name, param.definition.initValue);else Object.keys(this._params).forEach(function (name) {
        return _this.reset(name);
      });
    }

    /**
     * @callback ParameterBag~listenerCallback
     * @param {String} name - Parameter name.
     * @param {Mixed} value - Updated value of the parameter.
     * @param {Object} [meta=] - Given meta data of the parameter.
     */

    /**
     * Add listener to all param updates.
     *
     * @param {ParameterBag~listenerCallack} callback - Listener to register.
     */

  }, {
    key: 'addListener',
    value: function addListener(callback) {
      this._globalListeners.add(callback);
    }

    /**
     * Remove listener from all param changes.
     *
     * @param {ParameterBag~listenerCallack} callback - Listener to remove. If
     *  `null` remove all listeners.
     */

  }, {
    key: 'removeListener',
    value: function removeListener() {
      var callback = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

      if (callback === null) this._globalListeners.clear();else this._globalListeners.delete(callback);
    }

    /**
     * @callback ParameterBag~paramListenerCallack
     * @param {Mixed} value - Updated value of the parameter.
     * @param {Object} [meta=] - Given meta data of the parameter.
     */

    /**
     * Add listener to a given param updates.
     *
     * @param {String} name - Parameter name.
     * @param {ParameterBag~paramListenerCallack} callback - Function to apply
     *  when the value of the parameter changes.
     * @param {Boolean} [trigger=false] - Execute the callback immediately with
     *  current parameter value.
     */

  }, {
    key: 'addParamListener',
    value: function addParamListener(name, callback) {
      var trigger = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      this._paramsListeners[name].add(callback);

      if (trigger) {
        var _param = this._params[name];
        var value = _param.getValue();
        var metas = _param.definition.metas;
        callback(value, metas);
      }
    }

    /**
     * Remove listener from a given param updates.
     *
     * @param {String} name - Parameter name.
     * @param {ParameterBag~paramListenerCallack} callback - Listener to remove.
     *  If `null` remove all listeners.
     */

  }, {
    key: 'removeParamListener',
    value: function removeParamListener(name) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (callback === null) this._paramsListeners[name].clear();else this._paramsListeners[name].delete(callback);
    }
  }]);

  return ParameterBag;
}();

/**
 * Factory for the `ParameterBag` class.
 *
 * @param {Object<String, paramDefinition>} definitions - Object describing the
 *  parameters.
 * @param {Object<String, Mixed>} values - Initialization values for the
 *  parameters.
 * @return {ParameterBag}
 */


function parameters(definitions) {
  var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  var params = {};

  for (var name in values) {
    if (definitions.hasOwnProperty(name) === false) throw new Error('Unknown param "' + name + '"');
  }

  for (var _name in definitions) {
    if (params.hasOwnProperty(_name) === true) {
      throw new Error('Parameter "' + _name + '" already defined');
    }

    var definition = definitions[_name];

    if (!_paramTemplates2.default[definition.type]) {
      throw new Error('Unknown param type "' + definition.type + '"');
    }

    var _paramTemplates$defin = _paramTemplates2.default[definition.type],
        definitionTemplate = _paramTemplates$defin.definitionTemplate,
        typeCheckFunction = _paramTemplates$defin.typeCheckFunction;

    // if event property is set to true, the param must
    // be nullable and its default value is `undefined`

    if (definition.event === true) {
      definition.nullable = true;
      definition.default = null;
    }

    var value = void 0;

    if (values.hasOwnProperty(_name) === true) {
      value = values[_name];
    } else {
      value = definition.default;
    }

    // store init value in definition
    definition.initValue = value;

    if (!typeCheckFunction || !definitionTemplate) {
      throw new Error('Invalid param type definition "' + definition.type + '"');
    }

    params[_name] = new Param(_name, definitionTemplate, typeCheckFunction, definition, value);
  }

  return new ParameterBag(params, definitions);
}

/**
 * Register a new type for the `parameters` factory.
 * @param {String} typeName - Value that will be available as the `type` of a
 *  param definition.
 * @param {parameterDefinition} parameterDefinition - Object describing the
 *  parameter.
 */
parameters.defineType = function (typeName, parameterDefinition) {
  _paramTemplates2.default[typeName] = parameterDefinition;
};

exports.default = parameters;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcmFtZXRlcnMuanMiXSwibmFtZXMiOlsiUGFyYW0iLCJuYW1lIiwiZGVmaW5pdGlvblRlbXBsYXRlIiwidHlwZUNoZWNrRnVuY3Rpb24iLCJkZWZpbml0aW9uIiwidmFsdWUiLCJmb3JFYWNoIiwia2V5IiwiaGFzT3duUHJvcGVydHkiLCJFcnJvciIsInR5cGUiLCJudWxsYWJsZSIsIl90eXBlQ2hlY2tGdW5jdGlvbiIsImNvbnN0YW50IiwiUGFyYW1ldGVyQmFnIiwicGFyYW1zIiwiZGVmaW5pdGlvbnMiLCJfcGFyYW1zIiwiX2RlZmluaXRpb25zIiwiX2dsb2JhbExpc3RlbmVycyIsIlNldCIsIl9wYXJhbXNMaXN0ZW5lcnMiLCJ2YWx1ZXMiLCJmb3JjZVByb3BhZ2F0aW9uIiwicGFyYW0iLCJ1cGRhdGVkIiwic2V0VmFsdWUiLCJnZXRWYWx1ZSIsImV2ZW50IiwibWV0YXMiLCJsaXN0ZW5lciIsInNldCIsImluaXRWYWx1ZSIsIk9iamVjdCIsImtleXMiLCJyZXNldCIsImNhbGxiYWNrIiwiYWRkIiwiY2xlYXIiLCJkZWxldGUiLCJ0cmlnZ2VyIiwicGFyYW1ldGVycyIsInBhcmFtVGVtcGxhdGVzIiwiZGVmYXVsdCIsImRlZmluZVR5cGUiLCJ0eXBlTmFtZSIsInBhcmFtZXRlckRlZmluaXRpb24iXSwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7Ozs7Ozs7O0FBRUE7Ozs7Ozs7Ozs7OztJQVlNQSxLO0FBQ0osaUJBQVlDLElBQVosRUFBa0JDLGtCQUFsQixFQUFzQ0MsaUJBQXRDLEVBQXlEQyxVQUF6RCxFQUFxRUMsS0FBckUsRUFBNEU7QUFBQTs7QUFDMUVILHVCQUFtQkksT0FBbkIsQ0FBMkIsVUFBU0MsR0FBVCxFQUFjO0FBQ3ZDLFVBQUlILFdBQVdJLGNBQVgsQ0FBMEJELEdBQTFCLE1BQW1DLEtBQXZDLEVBQ0UsTUFBTSxJQUFJRSxLQUFKLG9DQUEyQ1IsSUFBM0MsV0FBcURNLEdBQXJELHFCQUFOO0FBQ0gsS0FIRDs7QUFLQSxTQUFLTixJ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LENBQUNGLGlCQUFELElBQXNCLENBQUNELGtCQUEzQixFQUErQztBQUM3QyxZQUFNLElBQUlPLEtBQUoscUNBQTRDTCxXQUFXTSxJQUF2RCxPQUFOO0FBQ0Q7O0FBRURLLFdBQU9kLEtBQVAsSUFBZSxJQUFJRCxLQUFKLENBQVVDLEtBQVYsRUFBZ0JDLGtCQUFoQixFQUFvQ0MsaUJBQXBDLEVBQXVEQyxVQUF2RCxFQUFtRUMsS0FBbkUsQ0FBZjtBQUNEOztBQUVELFNBQU8sSUFBSVMsWUFBSixDQUFpQkMsTUFBakIsRUFBeUJDLFdBQXpCLENBQVA7QUFDRDs7QUFFRDs7Ozs7OztBQU9BeUIsV0FBV0csVUFBWCxHQUF3QixVQUFTQyxRQUFULEVBQW1CQyxtQkFBbkIsRUFBd0M7QUFDOURKLDJCQUFlRyxRQUFmLElBQTJCQyxtQkFBM0I7QUFDRCxDQUZEOztrQkFJZUwsVSIsImZpbGUiOiJwYXJhbWV0ZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhcmFtVGVtcGxhdGVzIGZyb20gJy4vcGFyYW1UZW1wbGF0ZXMnO1xuXG4vKipcbiAqIEdlbmVyaWMgY2xhc3MgZm9yIHR5cGVkIHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBwYXJhbWV0ZXIuXG4gKiBAcGFyYW0ge0FycmF5fSBkZWZpbml0aW9uVGVtcGxhdGUgLSBMaXN0IG9mIG1hbmRhdG9yeSBrZXlzIGluIHRoZSBwYXJhbVxuICogIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSB0eXBlQ2hlY2tGdW5jdGlvbiAtIEZ1bmN0aW9uIHRvIGJlIHVzZWQgaW4gb3JkZXIgdG8gY2hlY2tcbiAqICB0aGUgdmFsdWUgYWdhaW5zdCB0aGUgcGFyYW0gZGVmaW5pdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBkZWZpbml0aW9uIC0gRGVmaW5pdGlvbiBvZiB0aGUgcGFyYW1ldGVyLlxuICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBWYWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgUGFyYW0ge1xuICBjb25zdHJ1Y3RvcihuYW1lLCBkZWZpbml0aW9uVGVtcGxhdGUsIHR5cGVDaGVja0Z1bmN0aW9uLCBkZWZpbml0aW9uLCB2YWx1ZSkge1xuICAgIGRlZmluaXRpb25UZW1wbGF0ZS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgaWYgKGRlZmluaXRpb24uaGFzT3duUHJvcGVydHkoa2V5KSA9PT0gZmFsc2UpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkZWZpbml0aW9uIGZvciBwYXJhbSBcIiR7bmFtZX1cIiwgJHtrZXl9IGlzIG5vdCBkZWZpbmVkYCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIHRoaXMudHlwZSA9IGRlZmluaXRpb24udHlwZTtcbiAgICB0aGlzLmRlZmluaXRpb24gPSBkZWZpbml0aW9uO1xuXG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5udWxsYWJsZSA9PT0gdHJ1ZSAmJiB2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudmFsdWUgPSB0eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgZGVmaW5pdGlvbiwgbmFtZSk7XG4gICAgfVxuXG4gICAgdGhpcy5fdHlwZUNoZWNrRnVuY3Rpb24gPSB0eXBlQ2hlY2tGdW5jdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjdXJyZW50IHZhbHVlLlxuICAgKiBAcmV0dXJuIHtNaXhlZH1cbiAgICovXG4gIGdldFZhbHVlKCkge1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBOZXcgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHJldHVybiB7Qm9vbGVhbn0gLSBgdHJ1ZWAgaWYgdGhlIHBhcmFtIGhhcyBiZWVuIHVwZGF0ZWQsIGZhbHNlIG90aGVyd2lzZVxuICAgKiAgKGUuZy4gaWYgdGhlIHBhcmFtZXRlciBhbHJlYWR5IGhhZCB0aGlzIHZhbHVlKS5cbiAgICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuZGVmaW5pdGlvbi5jb25zdGFudCA9PT0gdHJ1ZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGFzc2lnbmVtZW50IHRvIGNvbnN0YW50IHBhcmFtIFwiJHt0aGlzLm5hbWV9XCJgKTtcbiAgICB9XG5cbiAgICBpZiAoISh0aGlzLmRlZmluaXRpb24ubnVsbGFibGUgPT09IHRydWUgJiYgdmFsdWUgPT09IG51bGwpKSB7XG4gICAgICB2YWx1ZSA9IHRoaXMuX3R5cGVDaGVja0Z1bmN0aW9uKHZhbHVlLCB0aGlzLmRlZmluaXRpb24sIHRoaXMubmFtZSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMudmFsdWUgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cblxuXG4vKipcbiAqIEJhZyBvZiBwYXJhbWV0ZXJzLiBNYWluIGludGVyZmFjZSBvZiB0aGUgbGlicmFyeVxuICovXG5jbGFzcyBQYXJhbWV0ZXJCYWcge1xuICBjb25zdHJ1Y3RvcihwYXJhbXMsIGRlZmluaXRpb25zKSB7XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBwYXJhbWV0ZXJzLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIFBhcmFtPn1cbiAgICAgKiBAbmFtZSBfcGFyYW1zXG4gICAgICogQG1lbWJlcm9mIFBhcmFtZXRlckJhZ1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuXG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBkZWZpbml0aW9ucyB3aXRoIGluaXQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHR5cGUge09iamVjdDxTdHJpbmcsIHBhcmFtRGVmaW5pdGlvbj59XG4gICAgICogQG5hbWUgX2RlZmluaXRpb25zXG4gICAgICogQG1lbWJlcm9mIFBhcmFtZXRlckJhZ1xuICAgICAqIEBpbnN0YW5jZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5fZGVmaW5pdGlvbnMgPSBkZWZpbml0aW9ucztcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgZ2xvYmFsIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtTZXR9XG4gICAgICogQG5hbWUgX2dsb2JhbExpc3RlbmVyc1xuICAgICAqIEBtZW1iZXJvZiBQYXJhbWV0ZXJCYWdcbiAgICAgKiBAaW5zdGFuY2VcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuX2dsb2JhbExpc3RlbmVycyA9IG5ldyBTZXQoKTtcblxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgcGFyYW1zIGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBTZXQ+fVxuICAgICAqIEBuYW1lIF9wYXJhbXNMaXN0ZW5lcnNcbiAgICAgKiBAbWVtYmVyb2YgUGFyYW1ldGVyQmFnXG4gICAgICogQGluc3RhbmNlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnMgPSB7fTtcblxuICAgIC8vIGluaXRpYWxpemUgZW1wdHkgU2V0IGZvciBlYWNoIHBhcmFtXG4gICAgZm9yIChsZXQgbmFtZSBpbiBwYXJhbXMpXG4gICAgICB0aGlzLl9wYXJhbXNMaXN0ZW5lcnNbbmFtZV0gPSBuZXcgU2V0KCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBnaXZlbiBkZWZpbml0aW9ucyBhbG9uZyB3aXRoIHRoZSBpbml0aWFsaXphdGlvbiB2YWx1ZXMuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldERlZmluaXRpb25zKG5hbWUgPSBudWxsKSB7XG4gICAgaWYgKG5hbWUgIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLl9kZWZpbml0aW9uc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuX2RlZmluaXRpb25zO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdmFsdWVzIG9mIGFsbCBwYXJhbWV0ZXJzIGFzIGEgZmxhdCBvYmplY3QuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH1cbiAgICovXG4gIGdldFZhbHVlcygpIHtcbiAgICBjb25zdCB2YWx1ZXMgPSB7fTtcblxuICAgIGZvciAobGV0IG5hbWUgaW4gdGhpcy5fcGFyYW1zKSB7XG4gICAgICB2YWx1ZXNbbmFtZV0gPSB0aGlzLl9wYXJhbXNbbmFtZV0udmFsdWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBwYXJhbWV0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcmV0dXJuIHtNaXhlZH0gLSBWYWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKi9cbiAgZ2V0KG5hbWUpIHtcbiAgICBpZiAoIXRoaXMuX3BhcmFtc1tuYW1lXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlYWQgcHJvcGVydHkgdmFsdWUgb2YgdW5kZWZpbmVkIHBhcmFtZXRlciBcIiR7bmFtZX1cImApO1xuXG4gICAgcmV0dXJuIHRoaXMuX3BhcmFtc1tuYW1lXS52YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHZhbHVlIG9mIGEgcGFyYW1ldGVyLiBJZiB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciBpcyB1cGRhdGVkXG4gICAqIChha2EgaWYgcHJldmlvdXMgdmFsdWUgaXMgZGlmZmVyZW50IGZyb20gbmV3IHZhbHVlKSBhbGwgcmVnaXN0ZXJlZFxuICAgKiBjYWxsYmFja3MgYXJlIHJlZ2lzdGVyZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2ZvcmNlUHJvcGFnYXRpb249ZmFsc2VdIC0gaWYgdHJ1ZSwgcHJvcGFnYXRlIHZhbHVlIGV2ZW5cbiAgICogICAgaWYgdGhlIHZhbHVlIGhhcyBub3QgY2hhbmdlZC5cbiAgICogQHJldHVybiB7TWl4ZWR9IC0gTmV3IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBzZXQobmFtZSwgdmFsdWUsIGZvcmNlUHJvcGFnYXRpb24gPSBmYWxzZSkge1xuICAgIGNvbnN0IHBhcmFtID0gdGhpcy5fcGFyYW1zW25hbWVdO1xuICAgIGNvbnN0IHVwZGF0ZWQgPSBwYXJhbS5zZXRWYWx1ZSh2YWx1ZSk7XG4gICAgdmFsdWUgPSBwYXJhbS5nZXRWYWx1ZSgpO1xuXG4gICAgaWYgKHBhcmFtLmRlZmluaXRpb24uZXZlbnQgPT09IHRydWUpIHtcbiAgICAgIHBhcmFtLnNldFZhbHVlKG51bGwpO1xuICAgIH1cblxuICAgIGlmICh1cGRhdGVkIHx8wqBmb3JjZVByb3BhZ2F0aW9uKSB7XG4gICAgICBjb25zdCBtZXRhcyA9IHBhcmFtLmRlZmluaXRpb24ubWV0YXM7XG4gICAgICAvLyB0cmlnZ2VyIGdsb2JhbCBsaXN0ZW5lcnNcbiAgICAgIGZvciAobGV0IGxpc3RlbmVyIG9mIHRoaXMuX2dsb2JhbExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihuYW1lLCB2YWx1ZSwgbWV0YXMpO1xuICAgICAgfVxuXG4gICAgICAvLyB0cmlnZ2VyIHBhcmFtIGxpc3RlbmVyc1xuICAgICAgZm9yIChsZXQgbGlzdGVuZXIgb2YgdGhpcy5fcGFyYW1zTGlzdGVuZXJzW25hbWVdKSB7XG4gICAgICAgIGxpc3RlbmVyKHZhbHVlLCBtZXRhcyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmluZSBpZiB0aGUgYG5hbWVgIHBhcmFtZXRlciBleGlzdHMgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHJldHVybiB7Qm9vbGVhbn1cbiAgICovXG4gIGhhcyhuYW1lKSB7XG4gICAgcmV0dXJuICh0aGlzLl9wYXJhbXNbbmFtZV0pID8gdHJ1ZSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IGEgcGFyYW1ldGVyIHRvIGl0cyBpbml0IHZhbHVlLiBSZXNldCBhbGwgcGFyYW1ldGVycyBpZiBubyBhcmd1bWVudC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtuYW1lPW51bGxdIC0gTmFtZSBvZiB0aGUgcGFyYW1ldGVyIHRvIHJlc2V0LlxuICAgKi9cbiAgcmVzZXQobmFtZSA9IG51bGwpIHtcbiAgICBpZiAobmFtZSAhPT0gbnVsbClcbiAgICAgIHRoaXMuc2V0KG5hbWUsIHBhcmFtLmRlZmluaXRpb24uaW5pdFZhbHVlKTtcbiAgICBlbHNlXG4gICAgICBPYmplY3Qua2V5cyh0aGlzLl9wYXJhbXMpLmZvckVhY2goKG5hbWUpID0+IHRoaXMucmVzZXQobmFtZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBQYXJhbWV0ZXJCYWd+bGlzdGVuZXJDYWxsYmFja1xuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFBhcmFtZXRlciBuYW1lLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSAtIFVwZGF0ZWQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IFttZXRhPV0gLSBHaXZlbiBtZXRhIGRhdGEgb2YgdGhlIHBhcmFtZXRlci5cbiAgICovXG5cbiAgLyoqXG4gICAqIEFkZCBsaXN0ZW5lciB0byBhbGwgcGFyYW0gdXBkYXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJCYWd+bGlzdGVuZXJDYWxsYWNrfSBjYWxsYmFjayAtIExpc3RlbmVyIHRvIHJlZ2lzdGVyLlxuICAgKi9cbiAgYWRkTGlzdGVuZXIoY2FsbGJhY2spIHtcbiAgICB0aGlzLl9nbG9iYWxMaXN0ZW5lcnMuYWRkKGNhbGxiYWNrKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdGVuZXIgZnJvbSBhbGwgcGFyYW0gY2hhbmdlcy5cbiAgICpcbiAgICogQHBhcmFtIHtQYXJhbWV0ZXJCYWd+bGlzdGVuZXJDYWxsYWNrfSBjYWxsYmFjayAtIExpc3RlbmVyIHRvIHJlbW92ZS4gSWZcbiAgICogIGBudWxsYCByZW1vdmUgYWxsIGxpc3RlbmVycy5cbiAgICovXG4gIHJlbW92ZUxpc3RlbmVyKGNhbGxiYWNrID0gbnVsbCkge1xuICAgIGlmIChjYWxsYmFjayA9PT0gbnVsbClcbiAgICAgIHRoaXMuX2dsb2JhbExpc3RlbmVycy5jbGVhcigpO1xuICAgIGVsc2VcbiAgICAgIHRoaXMuX2dsb2JhbExpc3RlbmVycy5kZWxldGUoY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEBjYWxsYmFjayBQYXJhbWV0ZXJCYWd+cGFyYW1MaXN0ZW5lckNhbGxhY2tcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgLSBVcGRhdGVkIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbbWV0YT1dIC0gR2l2ZW4gbWV0YSBkYXRhIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuXG4gIC8qKlxuICAgKiBBZGQgbGlzdGVuZXIgdG8gYSBnaXZlbiBwYXJhbSB1cGRhdGVzLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIFBhcmFtZXRlciBuYW1lLlxuICAgKiBAcGFyYW0ge1BhcmFtZXRlckJhZ35wYXJhbUxpc3RlbmVyQ2FsbGFja30gY2FsbGJhY2sgLSBGdW5jdGlvbiB0byBhcHBseVxuICAgKiAgd2hlbiB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciBjaGFuZ2VzLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFt0cmlnZ2VyPWZhbHNlXSAtIEV4ZWN1dGUgdGhlIGNhbGxiYWNrIGltbWVkaWF0ZWx5IHdpdGhcbiAgICogIGN1cnJlbnQgcGFyYW1ldGVyIHZhbHVlLlxuICAgKi9cbiAgYWRkUGFyYW1MaXN0ZW5lcihuYW1lLCBjYWxsYmFjaywgdHJpZ2dlciA9IGZhbHNlKSB7XG4gICAgdGhpcy5fcGFyYW1zTGlzdGVuZXJzW25hbWVdLmFkZChjYWxsYmFjayk7XG5cbiAgICBpZiAodHJpZ2dlcikge1xuICAgICAgY29uc3QgcGFyYW0gPSB0aGlzLl9wYXJhbXNbbmFtZV07XG4gICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtLmdldFZhbHVlKCk7XG4gICAgICBjb25zdCBtZXRhcyA9IHBhcmFtLmRlZmluaXRpb24ubWV0YXM7XG4gICAgICBjYWxsYmFjayh2YWx1ZSwgbWV0YXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmUgbGlzdGVuZXIgZnJvbSBhIGdpdmVuIHBhcmFtIHVwZGF0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gUGFyYW1ldGVyIG5hbWUuXG4gICAqIEBwYXJhbSB7UGFyYW1ldGVyQmFnfnBhcmFtTGlzdGVuZXJDYWxsYWNrfSBjYWxsYmFjayAtIExpc3RlbmVyIHRvIHJlbW92ZS5cbiAgICogIElmIGBudWxsYCByZW1vdmUgYWxsIGxpc3RlbmVycy5cbiAgICovXG4gIHJlbW92ZVBhcmFtTGlzdGVuZXIobmFtZSwgY2FsbGJhY2sgPSBudWxsKSB7XG4gICAgaWYgKGNhbGxiYWNrID09PSBudWxsKVxuICAgICAgdGhpcy5fcGFyYW1zTGlzdGVuZXJzW25hbWVdLmNsZWFyKCk7XG4gICAgZWxzZVxuICAgICAgdGhpcy5fcGFyYW1zTGlzdGVuZXJzW25hbWVdLmRlbGV0ZShjYWxsYmFjayk7XG4gIH1cbn1cblxuLyoqXG4gKiBGYWN0b3J5IGZvciB0aGUgYFBhcmFtZXRlckJhZ2AgY2xhc3MuXG4gKlxuICogQHBhcmFtIHtPYmplY3Q8U3RyaW5nLCBwYXJhbURlZmluaXRpb24+fSBkZWZpbml0aW9ucyAtIE9iamVjdCBkZXNjcmliaW5nIHRoZVxuICogIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge09iamVjdDxTdHJpbmcsIE1peGVkPn0gdmFsdWVzIC0gSW5pdGlhbGl6YXRpb24gdmFsdWVzIGZvciB0aGVcbiAqICBwYXJhbWV0ZXJzLlxuICogQHJldHVybiB7UGFyYW1ldGVyQmFnfVxuICovXG5mdW5jdGlvbiBwYXJhbWV0ZXJzKGRlZmluaXRpb25zLCB2YWx1ZXMgPSB7fSkge1xuICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICBmb3IgKGxldCBuYW1lIGluIHZhbHVlcykge1xuICAgIGlmIChkZWZpbml0aW9ucy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA9PT0gZmFsc2UpXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW0gXCIke25hbWV9XCJgKTtcbiAgfVxuXG4gIGZvciAobGV0IG5hbWUgaW4gZGVmaW5pdGlvbnMpIHtcbiAgICBpZiAocGFyYW1zLmhhc093blByb3BlcnR5KG5hbWUpID09PSB0cnVlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7bmFtZX1cIiBhbHJlYWR5IGRlZmluZWRgKTtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZpbml0aW9uID0gZGVmaW5pdGlvbnNbbmFtZV07XG5cbiAgICBpZiAoIXBhcmFtVGVtcGxhdGVzW2RlZmluaXRpb24udHlwZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbSB0eXBlIFwiJHtkZWZpbml0aW9uLnR5cGV9XCJgKTtcbiAgICB9XG5cbiAgICBjb25zdCB7XG4gICAgICBkZWZpbml0aW9uVGVtcGxhdGUsXG4gICAgICB0eXBlQ2hlY2tGdW5jdGlvblxuICAgIH0gPSBwYXJhbVRlbXBsYXRlc1tkZWZpbml0aW9uLnR5cGVdO1xuXG4gICAgLy8gaWYgZXZlbnQgcHJvcGVydHkgaXMgc2V0IHRvIHRydWUsIHRoZSBwYXJhbSBtdXN0XG4gICAgLy8gYmUgbnVsbGFibGUgYW5kIGl0cyBkZWZhdWx0IHZhbHVlIGlzIGB1bmRlZmluZWRgXG4gICAgaWYgKGRlZmluaXRpb24uZXZlbnQgPT09IHRydWUpIHtcbiAgICAgIGRlZmluaXRpb24ubnVsbGFibGUgPSB0cnVlO1xuICAgICAgZGVmaW5pdGlvbi5kZWZhdWx0ID0gbnVsbDtcbiAgICB9XG5cbiAgICBsZXQgdmFsdWU7XG5cbiAgICBpZiAodmFsdWVzLmhhc093blByb3BlcnR5KG5hbWUpID09PSB0cnVlKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlc1tuYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBkZWZpbml0aW9uLmRlZmF1bHQ7XG4gICAgfVxuXG4gICAgLy8gc3RvcmUgaW5pdCB2YWx1ZSBpbiBkZWZpbml0aW9uXG4gICAgZGVmaW5pdGlvbi5pbml0VmFsdWUgPSB2YWx1ZTtcblxuICAgIGlmICghdHlwZUNoZWNrRnVuY3Rpb24gfHzCoCFkZWZpbml0aW9uVGVtcGxhdGUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBwYXJhbSB0eXBlIGRlZmluaXRpb24gXCIke2RlZmluaXRpb24udHlwZX1cImApO1xuICAgIH1cblxuICAgIHBhcmFtc1tuYW1lXSA9IG5ldyBQYXJhbShuYW1lLCBkZWZpbml0aW9uVGVtcGxhdGUsIHR5cGVDaGVja0Z1bmN0aW9uLCBkZWZpbml0aW9uLCB2YWx1ZSk7XG4gIH1cblxuICByZXR1cm4gbmV3IFBhcmFtZXRlckJhZyhwYXJhbXMsIGRlZmluaXRpb25zKTtcbn1cblxuLyoqXG4gKiBSZWdpc3RlciBhIG5ldyB0eXBlIGZvciB0aGUgYHBhcmFtZXRlcnNgIGZhY3RvcnkuXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZU5hbWUgLSBWYWx1ZSB0aGF0IHdpbGwgYmUgYXZhaWxhYmxlIGFzIHRoZSBgdHlwZWAgb2YgYVxuICogIHBhcmFtIGRlZmluaXRpb24uXG4gKiBAcGFyYW0ge3BhcmFtZXRlckRlZmluaXRpb259IHBhcmFtZXRlckRlZmluaXRpb24gLSBPYmplY3QgZGVzY3JpYmluZyB0aGVcbiAqICBwYXJhbWV0ZXIuXG4gKi9cbnBhcmFtZXRlcnMuZGVmaW5lVHlwZSA9IGZ1bmN0aW9uKHR5cGVOYW1lLCBwYXJhbWV0ZXJEZWZpbml0aW9uKSB7XG4gIHBhcmFtVGVtcGxhdGVzW3R5cGVOYW1lXSA9IHBhcmFtZXRlckRlZmluaXRpb247XG59XG5cbmV4cG9ydCBkZWZhdWx0IHBhcmFtZXRlcnM7XG4iXX0=