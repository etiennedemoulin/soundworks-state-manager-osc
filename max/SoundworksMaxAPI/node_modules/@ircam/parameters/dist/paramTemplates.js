'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
var min = Math.min;
var max = Math.max;

function clip(value) {
  var lower = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -Infinity;
  var upper = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : +Infinity;

  return max(lower, min(upper, value));
}

/**
 * Dictionnary of the available types. Each key correspond to the type of the
 * implemented param while the corresponding object value should the
 * {@link `paramDefinition`} of the defined type.
 *
 * typedef {Object} paramTemplates
 * @type {Object<String, paramTemplate>}
 */

/**
 * Definition of a parameter. The definition should at least contain the entries
 * `type` and `default`. Every parameter can also accept optionnal configuration
 * entries `constant` and `metas`.
 * Available definitions are:
 * - {@link booleanDefinition}
 * - {@link integerDefinition}
 * - {@link floatDefinition}
 * - {@link stringDefinition}
 * - {@link enumDefinition}
 *
 * typedef {Object} paramDefinition
 * @property {String} type - Type of the parameter.
 * @property {Mixed} default - Default value of the parameter if no
 *  initialization value is provided.
 * @property {Boolean} [constant=false] - Define if the parameter can be change
 *  after its initialization.
 * @property {Object} [metas=null] - Any user defined data associated to the
 *  parameter that couls be usefull in the application.
 */

exports.default = {
  /**
   * @typedef {Object} booleanDefinition
   * @property {String} [type='boolean'] - Define a boolean parameter.
   * @property {Boolean} default - Default value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Boolean} [event=true] - Define if the parameter is a volatile, e.g.
   *    set its value back to null after propagation of its value. When `true`,
   *    `nullable` is automatically set to `true` and `default` to `null`.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  boolean: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (typeof value !== 'boolean') throw new Error('Invalid value for boolean param "' + name + '": ' + value);

      return value;
    }
  },

  /**
   * @typedef {Object} integerDefinition
   * @property {String} [type='integer'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Number} [min=-Infinity] - Minimum value of the parameter.
   * @property {Number} [max=+Infinity] - Maximum value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Boolean} [event=true] - Define if the parameter is a volatile, e.g.
   *    set its value back to null after propagation of its value. When `true`,
   *    `nullable` is automatically set to `true` and `default` to `null`.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  integer: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (!(typeof value === 'number' && Math.floor(value) === value)) throw new Error('Invalid value for integer param "' + name + '": ' + value);

      return clip(value, definition.min, definition.max);
    }
  },

  /**
   * @typedef {Object} floatDefinition
   * @property {String} [type='float'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Number} [min=-Infinity] - Minimum value of the parameter.
   * @property {Number} [max=+Infinity] - Maximum value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Boolean} [event=true] - Define if the parameter is a volatile, e.g.
   *    set its value back to null after propagation of its value. When `true`,
   *    `nullable` is automatically set to `true` and `default` to `null`.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  float: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (typeof value !== 'number' || value !== value) // reject NaN
        throw new Error('Invalid value for float param "' + name + '": ' + value);

      return clip(value, definition.min, definition.max);
    }
  },

  /**
   * @typedef {Object} stringDefinition
   * @property {String} [type='string'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Boolean} [event=true] - Define if the parameter is a volatile, e.g.
   *    set its value back to null after propagation of its value. When `true`,
   *    `nullable` is automatically set to `true` and `default` to `null`.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  string: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (typeof value !== 'string') throw new Error('Invalid value for string param "' + name + '": ' + value);

      return value;
    }
  },

  /**
   * @typedef {Object} enumDefinition
   * @property {String} [type='enum'] - Define a boolean parameter.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Array} list - Possible values of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Boolean} [event=true] - Define if the parameter is a volatile, e.g.
   *    set its value back to null after propagation of its value. When `true`,
   *    `nullable` is automatically set to `true` and `default` to `null`.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  enum: {
    definitionTemplate: ['default', 'list'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      if (definition.list.indexOf(value) === -1) throw new Error('Invalid value for enum param "' + name + '": ' + value);

      return value;
    }
  },

  /**
   * @typedef {Object} anyDefinition
   * @property {String} [type='enum'] - Define a parameter of any type.
   * @property {Mixed} default - Default value of the parameter.
   * @property {Boolean} [constant=false] - Define if the parameter is constant.
   * @property {Boolean} [nullable=false] - Define if the parameter is nullable.
   * @property {Boolean} [event=true] - Define if the parameter is a volatile, e.g.
   *    set its value back to null after propagation of its value. When `true`,
   *    `nullable` is automatically set to `true` and `default` to `null`.
   * @property {Object} [metas={}] - Optionnal metadata of the parameter.
   */
  any: {
    definitionTemplate: ['default'],
    typeCheckFunction: function typeCheckFunction(value, definition, name) {
      // no check as it can have any type...
      return value;
    }
  }
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbInBhcmFtZXRlcnMuanMiXSwibmFtZXMiOlsibWluIiwiTWF0aCIsIm1heCIsImNsaXAiLCJ2YWx1ZSIsImxvd2VyIiwiSW5maW5pdHkiLCJ1cHBlciIsImJvb2xlYW4iLCJkZWZpbml0aW9uVGVtcGxhdGUiLCJ0eXBlQ2hlY2tGdW5jdGlvbiIsImRlZmluaXRpb24iLCJuYW1lIiwiRXJyb3IiLCJpbnRlZ2VyIiwiZmxvb3IiLCJmbG9hdCIsInN0cmluZyIsImVudW0iLCJsaXN0IiwiaW5kZXhPZiIsImFueSJdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxJQUFNQSxNQUFNQyxLQUFLRCxHQUFqQjtBQUNBLElBQU1FLE1BQU1ELEtBQUtDLEdBQWpCOztBQUVBLFNBQVNDLElBQVQsQ0FBY0MsS0FBZCxFQUEyRDtBQUFBLE1BQXRDQyxLQUFzQyx1RUFBOUIsQ0FBQ0MsUUFBNkI7QUFBQSxNQUFuQkMsS0FBbUIsdUVBQVgsQ0FBQ0QsUUFBVTs7QUFDekQsU0FBT0osSUFBSUcsS0FBSixFQUFXTCxJQUFJTyxLQUFKLEVBQVdILEtBQVgsQ0FBWCxDQUFQO0FBQ0Q7O0FBRUQ7Ozs7Ozs7OztBQVNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7a0JBcUJlO0FBQ2I7Ozs7Ozs7Ozs7O0FBV0FJLFdBQVM7QUFDUEMsd0JBQW9CLENBQUMsU0FBRCxDQURiO0FBRVBDLHFCQUZPLDZCQUVXTixLQUZYLEVBRWtCTyxVQUZsQixFQUU4QkMsSUFGOUIsRUFFb0M7QUFDekMsVUFBSSxPQUFPUixLQUFQLEtBQWlCLFNBQXJCLEVBQ0UsTUFBTSxJQUFJUyxLQUFKLHVDQUE4Q0QsSUFBOUMsV0FBd0RSLEtBQXhELENBQU47O0FBRUYsYUFBT0EsS0FBUDtBQUNEO0FBUE0sR0FaSTs7QUFzQmI7Ozs7Ozs7Ozs7Ozs7QUFhQVUsV0FBUztBQUNQTCx3QkFBb0IsQ0FBQyxTQUFELENBRGI7QUFFUEMscUJBRk8sNkJBRVdOLEtBRlgsRUFFa0JPLFVBRmxCLEVBRThCQyxJQUY5QixFQUVvQztBQUN6QyxVQUFJLEVBQUUsT0FBT1IsS0FBUCxLQUFpQixRQUFqQixJQUE2QkgsS0FBS2MsS0FBTCxDQUFXWCxLQUFYLE1BQXNCQSxLQUFyRCxDQUFKLEVBQ0UsTUFBTSxJQUFJUyxLQUFKLHVDQUE4Q0QsSUFBOUMsV0FBd0RSLEtBQXhELENBQU47O0FBRUYsYUFBT0QsS0FBS0MsS0FBTCxFQUFZTyxXQUFXWCxHQUF2QixFQUE0QlcsV0FBV1QsR0FBdkMsQ0FBUDtBQUNEO0FBUE0sR0FuQ0k7O0FBNkNiOzs7Ozs7Ozs7Ozs7O0FBYUFjLFNBQU87QUFDTFAsd0JBQW9CLENBQUMsU0FBRCxDQURmO0FBRUxDLHFCQUZLLDZCQUVhTixLQUZiLEVBRW9CTyxVQUZwQixFQUVnQ0MsSUFGaEMsRUFFc0M7QUFDekMsVUFBSSxPQUFPUixLQUFQLEtBQWlCLFFBQWpCLElBQTZCQSxVQUFVQSxLQUEzQyxFQUFrRDtBQUNoRCxjQUFNLElBQUlTLEtBQUoscUNBQTRDRCxJQUE1QyxXQUFzRFIsS0FBdEQsQ0FBTjs7QUFFRixhQUFPRCxLQUFLQyxLQUFMLEVBQVlPLFdBQVdYLEdBQXZCLEVBQTRCVyxXQUFXVCxHQUF2QyxDQUFQO0FBQ0Q7QUFQSSxHQTFETTs7QUFvRWI7Ozs7Ozs7Ozs7O0FBV0FlLFVBQVE7QUFDTlIsd0JBQW9CLENBQUMsU0FBRCxDQURkO0FBRU5DLHFCQUZNLDZCQUVZTixLQUZaLEVBRW1CTyxVQUZuQixFQUUrQkMsSUFGL0IsRUFFcUM7QUFDekMsVUFBSSxPQUFPUixLQUFQLEtBQWlCLFFBQXJCLEVBQ0UsTUFBTSxJQUFJUyxLQUFKLHNDQUE2Q0QsSUFBN0MsV0FBdURSLEtBQXZELENBQU47O0FBRUYsYUFBT0EsS0FBUDtBQUNEO0FBUEssR0EvRUs7O0FBeUZiOzs7Ozs7Ozs7Ozs7QUFZQWMsUUFBTTtBQUNKVCx3QkFBb0IsQ0FBQyxTQUFELEVBQVksTUFBWixDQURoQjtBQUVKQyxxQkFGSSw2QkFFY04sS0FGZCxFQUVxQk8sVUFGckIsRUFFaUNDLElBRmpDLEVBRXVDO0FBQ3pDLFVBQUlELFdBQVdRLElBQVgsQ0FBZ0JDLE9BQWhCLENBQXdCaEIsS0FBeEIsTUFBbUMsQ0FBQyxDQUF4QyxFQUNFLE1BQU0sSUFBSVMsS0FBSixvQ0FBMkNELElBQTNDLFdBQXFEUixLQUFyRCxDQUFOOztBQUVGLGFBQU9BLEtBQVA7QUFDRDtBQVBHLEdBckdPOztBQStHYjs7Ozs7Ozs7Ozs7QUFXQWlCLE9BQUs7QUFDSFosd0JBQW9CLENBQUMsU0FBRCxDQURqQjtBQUVIQyxxQkFGRyw2QkFFZU4sS0FGZixFQUVzQk8sVUFGdEIsRUFFa0NDLElBRmxDLEVBRXdDO0FBQ3pDO0FBQ0EsYUFBT1IsS0FBUDtBQUNEO0FBTEU7QUExSFEsQyIsImZpbGUiOiJwYXJhbWV0ZXJzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbWluID0gTWF0aC5taW47XG5jb25zdCBtYXggPSBNYXRoLm1heDtcblxuZnVuY3Rpb24gY2xpcCh2YWx1ZSwgbG93ZXIgPSAtSW5maW5pdHksIHVwcGVyID0gK0luZmluaXR5KSB7XG4gIHJldHVybiBtYXgobG93ZXIsIG1pbih1cHBlciwgdmFsdWUpKVxufVxuXG4vKipcbiAqIERpY3Rpb25uYXJ5IG9mIHRoZSBhdmFpbGFibGUgdHlwZXMuIEVhY2gga2V5IGNvcnJlc3BvbmQgdG8gdGhlIHR5cGUgb2YgdGhlXG4gKiBpbXBsZW1lbnRlZCBwYXJhbSB3aGlsZSB0aGUgY29ycmVzcG9uZGluZyBvYmplY3QgdmFsdWUgc2hvdWxkIHRoZVxuICoge0BsaW5rIGBwYXJhbURlZmluaXRpb25gfSBvZiB0aGUgZGVmaW5lZCB0eXBlLlxuICpcbiAqIHR5cGVkZWYge09iamVjdH0gcGFyYW1UZW1wbGF0ZXNcbiAqIEB0eXBlIHtPYmplY3Q8U3RyaW5nLCBwYXJhbVRlbXBsYXRlPn1cbiAqL1xuXG4vKipcbiAqIERlZmluaXRpb24gb2YgYSBwYXJhbWV0ZXIuIFRoZSBkZWZpbml0aW9uIHNob3VsZCBhdCBsZWFzdCBjb250YWluIHRoZSBlbnRyaWVzXG4gKiBgdHlwZWAgYW5kIGBkZWZhdWx0YC4gRXZlcnkgcGFyYW1ldGVyIGNhbiBhbHNvIGFjY2VwdCBvcHRpb25uYWwgY29uZmlndXJhdGlvblxuICogZW50cmllcyBgY29uc3RhbnRgIGFuZCBgbWV0YXNgLlxuICogQXZhaWxhYmxlIGRlZmluaXRpb25zIGFyZTpcbiAqIC0ge0BsaW5rIGJvb2xlYW5EZWZpbml0aW9ufVxuICogLSB7QGxpbmsgaW50ZWdlckRlZmluaXRpb259XG4gKiAtIHtAbGluayBmbG9hdERlZmluaXRpb259XG4gKiAtIHtAbGluayBzdHJpbmdEZWZpbml0aW9ufVxuICogLSB7QGxpbmsgZW51bURlZmluaXRpb259XG4gKlxuICogdHlwZWRlZiB7T2JqZWN0fSBwYXJhbURlZmluaXRpb25cbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSB0eXBlIC0gVHlwZSBvZiB0aGUgcGFyYW1ldGVyLlxuICogQHByb3BlcnR5IHtNaXhlZH0gZGVmYXVsdCAtIERlZmF1bHQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlciBpZiBub1xuICogIGluaXRpYWxpemF0aW9uIHZhbHVlIGlzIHByb3ZpZGVkLlxuICogQHByb3BlcnR5IHtCb29sZWFufSBbY29uc3RhbnQ9ZmFsc2VdIC0gRGVmaW5lIGlmIHRoZSBwYXJhbWV0ZXIgY2FuIGJlIGNoYW5nZVxuICogIGFmdGVyIGl0cyBpbml0aWFsaXphdGlvbi5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbWV0YXM9bnVsbF0gLSBBbnkgdXNlciBkZWZpbmVkIGRhdGEgYXNzb2NpYXRlZCB0byB0aGVcbiAqICBwYXJhbWV0ZXIgdGhhdCBjb3VscyBiZSB1c2VmdWxsIGluIHRoZSBhcHBsaWNhdGlvbi5cbiAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBib29sZWFuRGVmaW5pdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3R5cGU9J2Jvb2xlYW4nXSAtIERlZmluZSBhIGJvb2xlYW4gcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IGRlZmF1bHQgLSBEZWZhdWx0IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGNvbnN0YW50LlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtudWxsYWJsZT1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBudWxsYWJsZS5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZXZlbnQ9dHJ1ZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHZvbGF0aWxlLCBlLmcuXG4gICAqICAgIHNldCBpdHMgdmFsdWUgYmFjayB0byBudWxsIGFmdGVyIHByb3BhZ2F0aW9uIG9mIGl0cyB2YWx1ZS4gV2hlbiBgdHJ1ZWAsXG4gICAqICAgIGBudWxsYWJsZWAgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gYHRydWVgIGFuZCBgZGVmYXVsdGAgdG8gYG51bGxgLlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gW21ldGFzPXt9XSAtIE9wdGlvbm5hbCBtZXRhZGF0YSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKi9cbiAgYm9vbGVhbjoge1xuICAgIGRlZmluaXRpb25UZW1wbGF0ZTogWydkZWZhdWx0J10sXG4gICAgdHlwZUNoZWNrRnVuY3Rpb24odmFsdWUsIGRlZmluaXRpb24sIG5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHZhbHVlIGZvciBib29sZWFuIHBhcmFtIFwiJHtuYW1lfVwiOiAke3ZhbHVlfWApO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBpbnRlZ2VyRGVmaW5pdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3R5cGU9J2ludGVnZXInXSAtIERlZmluZSBhIGJvb2xlYW4gcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge01peGVkfSBkZWZhdWx0IC0gRGVmYXVsdCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW21pbj0tSW5maW5pdHldIC0gTWluaW11bSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge051bWJlcn0gW21heD0rSW5maW5pdHldIC0gTWF4aW11bSB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtjb25zdGFudD1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBjb25zdGFudC5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbbnVsbGFibGU9ZmFsc2VdIC0gRGVmaW5lIGlmIHRoZSBwYXJhbWV0ZXIgaXMgbnVsbGFibGUuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2V2ZW50PXRydWVdIC0gRGVmaW5lIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSB2b2xhdGlsZSwgZS5nLlxuICAgKiAgICBzZXQgaXRzIHZhbHVlIGJhY2sgdG8gbnVsbCBhZnRlciBwcm9wYWdhdGlvbiBvZiBpdHMgdmFsdWUuIFdoZW4gYHRydWVgLFxuICAgKiAgICBgbnVsbGFibGVgIGlzIGF1dG9tYXRpY2FsbHkgc2V0IHRvIGB0cnVlYCBhbmQgYGRlZmF1bHRgIHRvIGBudWxsYC5cbiAgICogQHByb3BlcnR5IHtPYmplY3R9IFttZXRhcz17fV0gLSBPcHRpb25uYWwgbWV0YWRhdGEgb2YgdGhlIHBhcmFtZXRlci5cbiAgICovXG4gIGludGVnZXI6IHtcbiAgICBkZWZpbml0aW9uVGVtcGxhdGU6IFsnZGVmYXVsdCddLFxuICAgIHR5cGVDaGVja0Z1bmN0aW9uKHZhbHVlLCBkZWZpbml0aW9uLCBuYW1lKSB7XG4gICAgICBpZiAoISh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInICYmIE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSkpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgaW50ZWdlciBwYXJhbSBcIiR7bmFtZX1cIjogJHt2YWx1ZX1gKTtcblxuICAgICAgcmV0dXJuIGNsaXAodmFsdWUsIGRlZmluaXRpb24ubWluLCBkZWZpbml0aW9uLm1heCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBmbG9hdERlZmluaXRpb25cbiAgICogQHByb3BlcnR5IHtTdHJpbmd9IFt0eXBlPSdmbG9hdCddIC0gRGVmaW5lIGEgYm9vbGVhbiBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TWl4ZWR9IGRlZmF1bHQgLSBEZWZhdWx0IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWluPS1JbmZpbml0eV0gLSBNaW5pbXVtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TnVtYmVyfSBbbWF4PStJbmZpbml0eV0gLSBNYXhpbXVtIHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGNvbnN0YW50LlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtudWxsYWJsZT1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBudWxsYWJsZS5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZXZlbnQ9dHJ1ZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHZvbGF0aWxlLCBlLmcuXG4gICAqICAgIHNldCBpdHMgdmFsdWUgYmFjayB0byBudWxsIGFmdGVyIHByb3BhZ2F0aW9uIG9mIGl0cyB2YWx1ZS4gV2hlbiBgdHJ1ZWAsXG4gICAqICAgIGBudWxsYWJsZWAgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gYHRydWVgIGFuZCBgZGVmYXVsdGAgdG8gYG51bGxgLlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gW21ldGFzPXt9XSAtIE9wdGlvbm5hbCBtZXRhZGF0YSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKi9cbiAgZmxvYXQ6IHtcbiAgICBkZWZpbml0aW9uVGVtcGxhdGU6IFsnZGVmYXVsdCddLFxuICAgIHR5cGVDaGVja0Z1bmN0aW9uKHZhbHVlLCBkZWZpbml0aW9uLCBuYW1lKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJyB8fMKgdmFsdWUgIT09IHZhbHVlKSAvLyByZWplY3QgTmFOXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgZmxvYXQgcGFyYW0gXCIke25hbWV9XCI6ICR7dmFsdWV9YCk7XG5cbiAgICAgIHJldHVybiBjbGlwKHZhbHVlLCBkZWZpbml0aW9uLm1pbiwgZGVmaW5pdGlvbi5tYXgpO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gc3RyaW5nRGVmaW5pdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3R5cGU9J3N0cmluZyddIC0gRGVmaW5lIGEgYm9vbGVhbiBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7TWl4ZWR9IGRlZmF1bHQgLSBEZWZhdWx0IHZhbHVlIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGNvbnN0YW50LlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtudWxsYWJsZT1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBudWxsYWJsZS5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZXZlbnQ9dHJ1ZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHZvbGF0aWxlLCBlLmcuXG4gICAqICAgIHNldCBpdHMgdmFsdWUgYmFjayB0byBudWxsIGFmdGVyIHByb3BhZ2F0aW9uIG9mIGl0cyB2YWx1ZS4gV2hlbiBgdHJ1ZWAsXG4gICAqICAgIGBudWxsYWJsZWAgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gYHRydWVgIGFuZCBgZGVmYXVsdGAgdG8gYG51bGxgLlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gW21ldGFzPXt9XSAtIE9wdGlvbm5hbCBtZXRhZGF0YSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKi9cbiAgc3RyaW5nOiB7XG4gICAgZGVmaW5pdGlvblRlbXBsYXRlOiBbJ2RlZmF1bHQnXSxcbiAgICB0eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3Igc3RyaW5nIHBhcmFtIFwiJHtuYW1lfVwiOiAke3ZhbHVlfWApO1xuXG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBAdHlwZWRlZiB7T2JqZWN0fSBlbnVtRGVmaW5pdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3R5cGU9J2VudW0nXSAtIERlZmluZSBhIGJvb2xlYW4gcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge01peGVkfSBkZWZhdWx0IC0gRGVmYXVsdCB2YWx1ZSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKiBAcHJvcGVydHkge0FycmF5fSBsaXN0IC0gUG9zc2libGUgdmFsdWVzIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW2NvbnN0YW50PWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGNvbnN0YW50LlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtudWxsYWJsZT1mYWxzZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBudWxsYWJsZS5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbZXZlbnQ9dHJ1ZV0gLSBEZWZpbmUgaWYgdGhlIHBhcmFtZXRlciBpcyBhIHZvbGF0aWxlLCBlLmcuXG4gICAqICAgIHNldCBpdHMgdmFsdWUgYmFjayB0byBudWxsIGFmdGVyIHByb3BhZ2F0aW9uIG9mIGl0cyB2YWx1ZS4gV2hlbiBgdHJ1ZWAsXG4gICAqICAgIGBudWxsYWJsZWAgaXMgYXV0b21hdGljYWxseSBzZXQgdG8gYHRydWVgIGFuZCBgZGVmYXVsdGAgdG8gYG51bGxgLlxuICAgKiBAcHJvcGVydHkge09iamVjdH0gW21ldGFzPXt9XSAtIE9wdGlvbm5hbCBtZXRhZGF0YSBvZiB0aGUgcGFyYW1ldGVyLlxuICAgKi9cbiAgZW51bToge1xuICAgIGRlZmluaXRpb25UZW1wbGF0ZTogWydkZWZhdWx0JywgJ2xpc3QnXSxcbiAgICB0eXBlQ2hlY2tGdW5jdGlvbih2YWx1ZSwgZGVmaW5pdGlvbiwgbmFtZSkge1xuICAgICAgaWYgKGRlZmluaXRpb24ubGlzdC5pbmRleE9mKHZhbHVlKSA9PT0gLTEpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgZW51bSBwYXJhbSBcIiR7bmFtZX1cIjogJHt2YWx1ZX1gKTtcblxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfSxcblxuICAvKipcbiAgICogQHR5cGVkZWYge09iamVjdH0gYW55RGVmaW5pdGlvblxuICAgKiBAcHJvcGVydHkge1N0cmluZ30gW3R5cGU9J2VudW0nXSAtIERlZmluZSBhIHBhcmFtZXRlciBvZiBhbnkgdHlwZS5cbiAgICogQHByb3BlcnR5IHtNaXhlZH0gZGVmYXVsdCAtIERlZmF1bHQgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICogQHByb3BlcnR5IHtCb29sZWFufSBbY29uc3RhbnQ9ZmFsc2VdIC0gRGVmaW5lIGlmIHRoZSBwYXJhbWV0ZXIgaXMgY29uc3RhbnQuXG4gICAqIEBwcm9wZXJ0eSB7Qm9vbGVhbn0gW251bGxhYmxlPWZhbHNlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIG51bGxhYmxlLlxuICAgKiBAcHJvcGVydHkge0Jvb2xlYW59IFtldmVudD10cnVlXSAtIERlZmluZSBpZiB0aGUgcGFyYW1ldGVyIGlzIGEgdm9sYXRpbGUsIGUuZy5cbiAgICogICAgc2V0IGl0cyB2YWx1ZSBiYWNrIHRvIG51bGwgYWZ0ZXIgcHJvcGFnYXRpb24gb2YgaXRzIHZhbHVlLiBXaGVuIGB0cnVlYCxcbiAgICogICAgYG51bGxhYmxlYCBpcyBhdXRvbWF0aWNhbGx5IHNldCB0byBgdHJ1ZWAgYW5kIGBkZWZhdWx0YCB0byBgbnVsbGAuXG4gICAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbWV0YXM9e31dIC0gT3B0aW9ubmFsIG1ldGFkYXRhIG9mIHRoZSBwYXJhbWV0ZXIuXG4gICAqL1xuICBhbnk6IHtcbiAgICBkZWZpbml0aW9uVGVtcGxhdGU6IFsnZGVmYXVsdCddLFxuICAgIHR5cGVDaGVja0Z1bmN0aW9uKHZhbHVlLCBkZWZpbml0aW9uLCBuYW1lKSB7XG4gICAgICAvLyBubyBjaGVjayBhcyBpdCBjYW4gaGF2ZSBhbnkgdHlwZS4uLlxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgfVxufVxuIl19